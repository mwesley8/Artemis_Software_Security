# Artemis_Software_Security

The developer’s role in solving security concerns is synonymous with the primary goals of information security. Software security aims to ensure that the information is not available to unauthorized individuals, the information is not altered from its original form during data transfers, and systems/companies/providers are held accountable. The developer helps the business grow by creating software that secures the overall system.

I read all of the supporting materials in the resource section of the modules. However, I did not see any specific examples of how to manually find vulnerabilities in the code base. The Vulnerabilities Process Flow Diagram does not mention how to manually find a vulnerability. The dependency check tool addressed common platform vulnerabilities andn dependencies. However, it was difficult to determine which vulnerabilities applied to a specific situation.

I was recently promoted to Global Rain’s new agile scrum team. I was tasked with examining Artemis Financials’ web-based software application to identify any security vulnerabilities. As the agile security officer for the financial company, I needed to ensure that the organization’s use of secure communications channels to domestic and international customers met government export regulations.

The main method in the Server Application Class invokes the Spring Application. Also, the class has two methods with Request Mapping and Rest Controller annotations. First, the layered approach that I took involves calling the method after the Request Mapping annotation.
The method declares a string variable and assigns it to a string literal. Another string variable is declared and assigned to the return value of a method call passed with an argument.

Next, the method called creates a SHA-256 message digest instance. The message digest instance is updated after transposing the argument into a byte array. Then, the byte array is transformed into a hash byte array using the digest method. The hash byte array is passed to a method that converts the hash array into a unique hexadecimal string. The string is returned.

A server-side key, keystore, password, alias, and certificate were created. The certificate was self-signed and imported into the keystore. Additionally, a client-side trust store and password were created. The certificate was imported into the trust store.

The applications properties file was changed to execute on a secure port (8443). A secure socket layer was enabled to true. Also, the file contained the key alias, key/keystore password, key type, and trust store password. Class paths to the key store and trust were added. The data was encoded into a hash and transformed into a hexadecimal string. I was able to output data using html that was displayed on a HTTPS site.

For future assignments and duties, I will review that NIST Special Publication covering guidelines for conducting information security assessments. The SANS institute provides cybersecurity training and education. I had an opportunity to work with the OWASP dependency tool. It was a great way to check the code base against common platform vulnerabilities and exposures. I will follow the Center for Internet Security best practices for addressing common cybersecurity risks.

This artifact demonstrates my ability to manually and statically inspect code for security vulnerabilities. I created a self-signed certificate, keystore, trust store, and output html on a HTTPS site. The output was a greeting that was encoded into a SHA-256 byte array and converted to a hexadecimal string.
